/*
Copyright (c) 2009 The Regents of the University of California.
All rights reserved.
Permission is hereby granted, without written agreement and without
license or royalty fees, to use, copy, modify, and distribute this
software and its documentation for any purpose, provided that the above
copyright notice and the following two paragraphs appear in all copies
of this software.

IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
ENHANCEMENTS, OR MODIFICATIONS..
 */
package org.clothocad.hibernate.data;
// Generated Jun 1, 2010 8:47:54 PM by Hibernate Tools 3.2.1.GA

import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import org.clothocore.api.core.Collector;
import org.clothocore.api.data.ObjBase;
import org.clothocore.api.data.ObjBase.ObjBaseDatum;
import org.clothocore.api.data.ObjType;
import org.clothocore.api.data.Strain;
import org.clothocore.api.data.Strain.StrainDatum;
import org.clothocore.api.data.Strain.genomeModification;
import org.clothocad.hibernate.hibernateDatum;
import org.clothocad.hibernate.HibernateConnection;

/**
 * StrainTable generated by hbm2java
 */
public class StrainTable implements java.io.Serializable, hibernateDatum {

    public static ObjType getType( Enum field ) {
        if ( field.getDeclaringClass() != Strain.Fields.class ) {
            return null;
        }

        Strain.Fields f = (Strain.Fields) field;

        switch ( f ) {
            case AUTHOR:
                return ObjType.PERSON;
            case GENBANK_FILE:
                return ObjType.ATTACHMENT;
            case PARENT_STRAIN:
                return ObjType.STRAIN;
            case CHILD_STRAINS:
                return ObjType.STRAIN;
            default:
                return null;
        }
    }

    public StrainTable( Strain s ) {

        System.out.println( "saving strainTable value of _genbankFileUUID" + s.getGenbankFile() );
        this.idStrain = s.getUUID();
        if ( s.getParentStrain() != null ) {
            this.strainTable = new StrainTable( s.getParentStrain().getUUID() );
        }
        if ( s.getGenbankFile() != null ) {
            this.attachmentTable = new AttachmentTable( s.getGenbankFile().getUUID() );
        }
        this.personTable = new PersonTable( s.getAuthor().getUUID() );
        this.isBasic = s.isBasic();
        this.genomeId = s.getGenomeID();
        this.strainType = s.getStrainType().toString();
        this.dateCreated = s.getDateCreated();
        this.lastModified = s.getLastModified();
        this.name = s.getName();
        this.description = s.getDescription();
        this.riskGroup = s.getRiskGroup();

        if(!s.isInDatabase()) {
            needsSecondaryProcessing = true;
            return;
        }

        HashSet<String> existingLinks = new HashSet<String>();

        //Remove old Note:Strain links
        String query = "from StrainNoteXref where strainId='" + idStrain + "'";
        Iterator xrefs = HibernateConnection.connection.query( query );
        while ( xrefs.hasNext() ) {
            StrainNoteXref cx = (StrainNoteXref) xrefs.next();
            String uuid = cx.getId().getNoteId();
            existingLinks.add( uuid );
            if ( !s.getNoteLinks().contains( uuid ) ) {
                HibernateConnection.connection.deleteDatum( cx );
            }
        }

        //Save all the new Xrefs for notes
        for ( String uuid : s.getNoteLinks() ) {
            if ( !existingLinks.contains( uuid ) ) {
                StrainNoteXrefId cxi = new StrainNoteXrefId( idStrain, uuid );
                StrainNoteXref cxr = new StrainNoteXref( cxi, new NoteTable( uuid ), new StrainTable( idStrain ) );
                strainNoteXrefs.add( cxr );
                HibernateConnection.connection.saveDatum( cxr );
            }
        }

        //Remove old Strain:Plasmid links
        query = "from StrainPlasmidXref where strainId='" + idStrain + "'";
        xrefs = HibernateConnection.connection.query( query );
        while ( xrefs.hasNext() ) {
            StrainPlasmidXref cx = (StrainPlasmidXref) xrefs.next();
            String uuid = cx.getId().getPlasmidId();
            existingLinks.add( uuid );
            if ( !s.getAllPlasmidLinks().contains( uuid ) ) {
                HibernateConnection.connection.deleteDatum( cx );
            }
        }

        //Save all the new Xrefs for episomal plasmids
        for ( String uuid : s.getEpisomalPlasmidsLinks() ) {
            if ( !existingLinks.contains( uuid ) ) {
                StrainPlasmidXrefId cxi = new StrainPlasmidXrefId( idStrain, uuid );
                StrainPlasmidXref cxr = new StrainPlasmidXref( cxi, new PlasmidTable( uuid ), new StrainTable( idStrain ) );
                cxr.setIsGenomic( false );
                cxr.setPersonTable( new PersonTable( Collector.getCurrentUser().getUUID() ) );
                strainPlasmidXrefs.add( cxr );
                HibernateConnection.connection.saveDatum( cxr );
            }
        }

        //Save all the new Xrefs for genomic plasmids
        for ( genomeModification genmod : s.getGenomeModifications() ) {
            if ( !existingLinks.contains( genmod._plasmidLink ) || genmod._isChanged ) {
                StrainPlasmidXrefId cxi = new StrainPlasmidXrefId( idStrain, genmod._plasmidLink );
                StrainPlasmidXref cxr = new StrainPlasmidXref( cxi, new PlasmidTable( genmod._plasmidLink ), new StrainTable( idStrain ) );
                cxr.setIsGenomic( true );
                cxr.setRevComp( genmod._isRevComp );
                cxr.setGenomeStart( genmod._startOnGenome );
                cxr.setGenomeEnd( genmod._endOnGenome );
                cxr.setPersonTable( new PersonTable( Collector.getCurrentUser().getUUID() ) );
                strainPlasmidXrefs.add( cxr );
                HibernateConnection.connection.saveDatum( cxr );
            }
        }
    }

    @Override
    public void runSecondaryProcessing(ObjBase obj) {
        Strain s = (Strain) obj;

        //Save all the new Xrefs for notes
        for ( String uuid : s.getNoteLinks() ) {
            StrainNoteXrefId cxi = new StrainNoteXrefId( idStrain, uuid );
            StrainNoteXref cxr = new StrainNoteXref( cxi, new NoteTable( uuid ), new StrainTable( idStrain ) );
            strainNoteXrefs.add( cxr );
            HibernateConnection.connection.saveDatum( cxr );
        }

        //Save all the new Xrefs for episomal plasmids
        for ( String uuid : s.getEpisomalPlasmidsLinks() ) {
            StrainPlasmidXrefId cxi = new StrainPlasmidXrefId( idStrain, uuid );
            StrainPlasmidXref cxr = new StrainPlasmidXref( cxi, new PlasmidTable( uuid ), new StrainTable( idStrain ) );
            cxr.setIsGenomic( false );
            cxr.setPersonTable( new PersonTable( Collector.getCurrentUser().getUUID() ) );
            strainPlasmidXrefs.add( cxr );
            HibernateConnection.connection.saveDatum( cxr );
        }

        //Save all the new Xrefs for genomic plasmids
        for ( genomeModification genmod : s.getGenomeModifications() ) {
            StrainPlasmidXrefId cxi = new StrainPlasmidXrefId( idStrain, genmod._plasmidLink );
            StrainPlasmidXref cxr = new StrainPlasmidXref( cxi, new PlasmidTable( genmod._plasmidLink ), new StrainTable( idStrain ) );
            cxr.setIsGenomic( true );
            cxr.setRevComp( genmod._isRevComp );
            cxr.setGenomeStart( genmod._startOnGenome );
            cxr.setGenomeEnd( genmod._endOnGenome );
            cxr.setPersonTable( new PersonTable( Collector.getCurrentUser().getUUID() ) );
            strainPlasmidXrefs.add( cxr );
            HibernateConnection.connection.saveDatum( cxr );
        }
        needsSecondaryProcessing = false;
    }

    @Override
    public boolean needsSecondaryProcessing() {
        return this.needsSecondaryProcessing;
    }

    @Override
    public ObjBase getObject() {
        Strain.StrainDatum d = (StrainDatum) getObjBaseDatum();
        Strain s = new Strain( d );
        return s;
    }

    @Override
    public ObjBaseDatum getObjBaseDatum() {
        String parentstrain = null;
        if ( strainTable != null ) {
            parentstrain = strainTable.getIdStrain();
        }
        String genbank = null;
        if ( attachmentTable != null ) {
            genbank = attachmentTable.getIdAttachment();
        }

        //find all the note links
        HashSet<String> noteLinks = new HashSet<String>();
        Iterator<hibernateDatum> objs = this.strainNoteXrefs.iterator();
        while ( objs.hasNext() ) {
            StrainNoteXref cx = (StrainNoteXref) objs.next();
            String uuid = cx.getId().getNoteId();
            noteLinks.add( uuid );
        }

        //find all the plasmid links
        HashSet<String> episomalLinks = new HashSet<String>();
        HashSet<StrainPlasmidXref> toBeProcessed = new HashSet<StrainPlasmidXref>();

        objs = this.strainPlasmidXrefs.iterator();
        while ( objs.hasNext() ) {
            StrainPlasmidXref cx = (StrainPlasmidXref) objs.next();
            String uuid = cx.getId().getPlasmidId();
            boolean isgenomic = cx.getIsGenomic();

            if ( isgenomic ) {
                toBeProcessed.add( cx );
            } else {
                episomalLinks.add( uuid );
            }
        }

        if ( riskGroup == null ) {
            riskGroup = -1;
        }

        Strain.StrainDatum d = new Strain.StrainDatum();
        d.uuid = idStrain;
        d.name = name;
        d._description = description;
        d.dateCreated = dateCreated;
        d.lastModified = lastModified;
        d._riskGroup = riskGroup;
        d._parentStrain = parentstrain;
        d._genbankFileUUID = genbank;
        d._authorUUID = personTable.getIdPerson();
        d._isBasic = isBasic;
        d._genomeId = genomeId;
        d._strainType = Strain.strainType.valueOf( strainType );
        d._noteLinks = noteLinks;
        d._episomeLinks = episomalLinks;

        //THIS SHOULD BE IN DATUM

        for ( StrainPlasmidXref cx : toBeProcessed ) {
            try {
                String GMuuid = cx.getId().getPlasmidId();
                int GMstart = cx.getGenomeStart();
                int GMend = cx.getGenomeEnd();
                boolean GMrc = cx.getRevComp();

                genomeModification gm =  d.staticStrain.new genomeModification(GMuuid, GMstart, GMend, GMrc);

                d._genModLinks.add(gm);
            }  catch (Exception err) {
                err.printStackTrace();
            }
        }

        return d;
    }

    @Override
    public String getUUID() {
        return idStrain;
    }

    @Override
    public Date getLastModified() {
        return lastModified;
    }

    @Override
    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }

    public static String translate( Enum field ) {
        if ( field.getDeclaringClass() != Strain.Fields.class ) {
            return null;
        }

        Strain.Fields f = (Strain.Fields) field;

        switch ( f ) {
            case NAME:
                return "name";
            case DESCRIPTION:
                return "description";
            case DATE_CREATED:
                return "dateCreated";
            case LAST_MODIFIED:
                return "lastModified";
            case IS_BASIC:
                return "isBasic";
            case STRAIN_TYPE:
                return "strainType";
            case RISK_GROUP:
                return "riskGroup";
            case GENBANK_ID:
                return "attachmentTable";
            case PARENT_STRAIN:
                return "strainTable";
            case CHILD_STRAINS:
                return "strainTables";
            case GENBANK_FILE:
                return "attachmentTable";
            case AUTHOR:
                return "personTable";
            default:
                return null;
        }
    }

    private boolean needsSecondaryProcessing = false;
    /***** AUTO-GENERATED CODE *****/
    private String idStrain;
    private StrainTable strainTable;
    private AttachmentTable attachmentTable;
    private PersonTable personTable;
    private String name;
    private String description;
    private Boolean isBasic;
    private String genomeId;
    private String strainType;
    private Short riskGroup;
    private Date dateCreated;
    private Date lastModified;
    private Set strainPlasmidXrefs = new HashSet( 0 );
    private Set sampleTables = new HashSet( 0 );
    private Set strainTables = new HashSet( 0 );
    private Set strainNoteXrefs = new HashSet( 0 );

    public StrainTable() {
    }

    public StrainTable( String idStrain ) {
        this.idStrain = idStrain;
    }

    public StrainTable( String idStrain, StrainTable strainTable, AttachmentTable attachmentTable, PersonTable personTable, String name, String description, Boolean isBasic, String genomeId, String strainType, Short riskGroup, Date dateCreated, Date lastModified, Set strainPlasmidXrefs, Set sampleTables, Set strainTables, Set strainNoteXrefs ) {
        this.idStrain = idStrain;
        this.strainTable = strainTable;
        this.attachmentTable = attachmentTable;
        this.personTable = personTable;
        this.name = name;
        this.description = description;
        this.isBasic = isBasic;
        this.genomeId = genomeId;
        this.strainType = strainType;
        this.riskGroup = riskGroup;
        this.dateCreated = dateCreated;
        this.lastModified = lastModified;
        this.strainPlasmidXrefs = strainPlasmidXrefs;
        this.sampleTables = sampleTables;
        this.strainTables = strainTables;
        this.strainNoteXrefs = strainNoteXrefs;
    }

    public String getIdStrain() {
        return this.idStrain;
    }

    public void setIdStrain( String idStrain ) {
        this.idStrain = idStrain;
    }

    public StrainTable getStrainTable() {
        return this.strainTable;
    }

    public void setStrainTable( StrainTable strainTable ) {
        this.strainTable = strainTable;
    }

    public AttachmentTable getAttachmentTable() {
        return this.attachmentTable;
    }

    public void setAttachmentTable( AttachmentTable attachmentTable ) {
        this.attachmentTable = attachmentTable;
    }

    public PersonTable getPersonTable() {
        return this.personTable;
    }

    public void setPersonTable( PersonTable personTable ) {
        this.personTable = personTable;
    }

    public void setName( String name ) {
        this.name = name;
    }

    public void setDescription( String desc ) {
        this.description = desc;
    }

    public Boolean getIsBasic() {
        return this.isBasic;
    }

    public void setIsBasic( Boolean isBasic ) {
        this.isBasic = isBasic;
    }

    public String getGenomeId() {
        return this.genomeId;
    }

    public void setGenomeId( String genomeId ) {
        this.genomeId = genomeId;
    }

    public String getStrainType() {
        return this.strainType;
    }

    public void setStrainType( String strainType ) {
        this.strainType = strainType;
    }

    public Short getRiskGroup() {
        return this.riskGroup;
    }

    public void setRiskGroup( Short riskGroup ) {
        this.riskGroup = riskGroup;
    }

    public Date getDateCreated() {
        return this.dateCreated;
    }

    public void setDateCreated( Date dateCreated ) {
        this.dateCreated = dateCreated;
    }

    public void setLastModified( Date lastModified ) {
        this.lastModified = lastModified;
    }

    public Set getStrainPlasmidXrefs() {
        return this.strainPlasmidXrefs;
    }

    public void setStrainPlasmidXrefs( Set strainPlasmidXrefs ) {
        this.strainPlasmidXrefs = strainPlasmidXrefs;
    }

    public Set getSampleTables() {
        return this.sampleTables;
    }

    public void setSampleTables( Set sampleTables ) {
        this.sampleTables = sampleTables;
    }

    public Set getStrainTables() {
        return this.strainTables;
    }

    public void setStrainTables( Set strainTables ) {
        this.strainTables = strainTables;
    }

    public Set getStrainNoteXrefs() {
        return this.strainNoteXrefs;
    }

    public void setStrainNoteXrefs( Set strainNoteXrefs ) {
        this.strainNoteXrefs = strainNoteXrefs;
    }
}
